[
  {
    "objectID": "programming.html",
    "href": "programming.html",
    "title": "Posts in Programming",
    "section": "",
    "text": "Order By\n      Default\n      \n        Date - Oldest\n      \n      \n        Date - Newest\n      \n      \n        Title\n      \n    \n  \n    \n      \n      \n    \n\n\n\n\n\n\nTitle\n\n\n\nDate\n\n\n\n\n\n\n\n\nNewton’s Root-Finding Method\n\n\nSep 17, 2025\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/cheat-sheet.html",
    "href": "posts/cheat-sheet.html",
    "title": "Quarto Cheat Sheet",
    "section": "",
    "text": "This static website is generated using Quarto, which allows creating dynamic content with Python, and writing markdown, including equations, citations, crossrefs, figure panels, etc.\nThis document is used as a Quarto cheat sheet."
  },
  {
    "objectID": "posts/cheat-sheet.html#a-latex-equation",
    "href": "posts/cheat-sheet.html#a-latex-equation",
    "title": "Quarto Cheat Sheet",
    "section": "1. A \\(\\LaTeX\\) Equation",
    "text": "1. A \\(\\LaTeX\\) Equation\n\\[g(x) = \\frac{1}{\\sqrt{2\\pi\\sigma^2}}e^{-\\frac{1}{2}(x-\\mu)^2/\\sigma^2}\\]"
  },
  {
    "objectID": "posts/cheat-sheet.html#interactive-plotly-plot-with-sliders",
    "href": "posts/cheat-sheet.html#interactive-plotly-plot-with-sliders",
    "title": "Quarto Cheat Sheet",
    "section": "2. Interactive Plotly Plot with Sliders",
    "text": "2. Interactive Plotly Plot with Sliders\n\n\nCode\nimport numpy as np\nimport plotly.graph_objects as go\n\nx = np.arange(0, 10, 0.01)\nn = 51  # Number of traces\nactive = 10  # Initially active slider step\nsteps = []  # Slider steps\n\n# Create a figure and a trace for each slider step.\nfig = go.Figure()\nfor i, f in enumerate(np.linspace(0, 5, n)):\n    trace = go.Scatter(x=x, y=np.sin(f * x), visible=(i == active), name=\"f = \" + str(f))\n    fig.add_trace(trace)\n    \n    steps.append({\n        \"method\": \"update\",\n        \"label\": f\"{f:.2f}\",  # This is the label the slider shows.\n        \"args\": [{\"visible\": [i == j for j in range(n)]}],  # i-th trace is visible in this step.\n    })\n\nsliders = [{\n    \"active\": active,  # Initially active step.\n    \"currentvalue\": {\"prefix\": \"Frequency: \"},  # Slider info text configuration.\n    \"steps\": steps\n}]\n\nfig.update_layout(\n    sliders=sliders,\n    template=\"seaborn\"\n)\nfig.update_yaxes(range=[-1.1, 1.1])  # y-axis are automatically resized otherwise.\n\nfig.show()"
  },
  {
    "objectID": "posts/cheat-sheet.html#interactive-image-hover",
    "href": "posts/cheat-sheet.html#interactive-image-hover",
    "title": "Quarto Cheat Sheet",
    "section": "3. Interactive Image Hover",
    "text": "3. Interactive Image Hover\n\n\nCode\nimport numpy as np\nimport plotly.express as px\n\n# Create a 16x16 RGB image\nimg = np.random.rand(16, 16, 3)\nmagnitude = np.linalg.norm(img, axis=2)\n\nfig = px.imshow(magnitude, color_continuous_scale=\"Viridis\", title=\"Hover me\")\nfig.update_traces(\n    hovertemplate=\"Coord: (%{x}, %{y})&lt;br&gt;Value: (%{customdata[0]:.3f}, %{customdata[1]:.3f}, %{customdata[2]:.3f})&lt;extra&gt;&lt;/extra&gt;\",\n    customdata=img\n)\nfig.show()"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "EdwinBennink.github.io",
    "section": "",
    "text": "This website shares notes and reflections on (medical) image analysis, programming, and mathematics."
  },
  {
    "objectID": "index.html#about-the-author",
    "href": "index.html#about-the-author",
    "title": "EdwinBennink.github.io",
    "section": "About the author",
    "text": "About the author\nEdwin Bennink works as a researcher and research software engineer for the Medical Physics Group and the Image Sciences Institute (UMC Utrecht - Dept. of Radiology).\nHe received the MSc degree (cum laude) in biomedical engineering from the Eindhoven University of Technology in 2007. In 2016, he received his PhD from the Utrecht University, with a research project on quantitative CT brain perfusion analysis. From 2007 to 2011 he worked as senior software developer for Scientific Volume Imaging BV.\nBesides doing research in CT imaging in acute stroke and supporting various image-analysis related projects throughout the UMC Utrecht, Edwin is one of the lead developers of IMAGR, the image analytics infrastructure that brings deep-learning algorithms into the clinical workflow."
  },
  {
    "objectID": "all.html",
    "href": "all.html",
    "title": "Browse by Topic",
    "section": "",
    "text": "Order By\n      Default\n      \n        Date - Oldest\n      \n      \n        Date - Newest\n      \n      \n        Title\n      \n    \n  \n    \n      \n      \n    \n\n\n\n\n\n\nTitle\n\n\n\nDate\n\n\n\n\n\n\n\n\nNewton’s Root-Finding Method\n\n\nSep 17, 2025\n\n\n\n\n\n\nQuarto Cheat Sheet\n\n\nSep 15, 2025\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "image-analysis.html",
    "href": "image-analysis.html",
    "title": "Posts in Image Analysis",
    "section": "",
    "text": "Order By\n      Default\n      \n        Date - Oldest\n      \n      \n        Date - Newest\n      \n      \n        Title\n      \n    \n  \n    \n      \n      \n    \n\n\n\n\nTitle\nDate\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "math.html",
    "href": "math.html",
    "title": "Posts in Image Math",
    "section": "",
    "text": "Order By\n      Default\n      \n        Date - Oldest\n      \n      \n        Date - Newest\n      \n      \n        Title\n      \n    \n  \n    \n      \n      \n    \n\n\n\n\n\n\nTitle\n\n\n\nDate\n\n\n\n\n\n\n\n\nNewton’s Root-Finding Method\n\n\nSep 17, 2025\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/newtons-method.html",
    "href": "posts/newtons-method.html",
    "title": "Newton’s Root-Finding Method",
    "section": "",
    "text": "At the core of many research software applications you’ll find optimization functions. Sometimes, the optimization task is complex and thus requires a complex optimization routine. In other cases, however, simpler and more elegant methods exist and complex optimization routines might introduce more overhead than necessary.\nIn this post, I’ll show how Newton’s method can be helpful in finding a root of an nth order polynomial, when a close approximation is known. Newton’s method is simple (it requires just a few lines of code) and fast (the rate of convergence is at least quadratic). I recently used it for diffusion MRI software, so I’ll use that as an example.\nIn diffusion MRI, the b-value for trapezoidal gradient pulses is given by \\[b = \\gamma^2G^2\\left(\\delta^2\\left(\\Delta - \\frac{1}{3}\\delta\\right) + \\frac{1}{30}\\xi^2 - \\frac{1}{6}\\delta\\xi^2\\right),\\] where \\(\\xi\\) is the rise time \\(G/s_{max}\\).\nIn order to calculate the gradient magnitude \\(G\\) for a given \\(\\gamma\\), \\(s_{max}\\), \\(b\\), \\(\\delta\\), and \\(\\Delta\\), we need to find the root for \\[0 = \\left(\\frac{\\gamma^2}{30s_{max}^2}\\right)G^5 - \\left(\\frac{\\gamma^2\\delta}{6s_{max}²}\\right)G^4 + \\gamma^2\\delta^2\\left(\\Delta - \\frac{1}{3}\\delta\\right)G^2 - b\\label{eq:1} \\tag{1}\\]\nSince we know that the term for \\(G^5\\) is significantly smaller than the others, we can use the solution to \\[0 = -\\left(\\frac{\\gamma^2\\delta}{6s_{max}²}\\right)\\tilde{G}^4 + \\gamma^2\\delta^2\\left(\\Delta - \\frac{1}{3}\\delta\\right)\\tilde{G}^2 - b\\] as an initial guess. Solving this quadratic equation for \\(\\tilde{G}^2\\) gives \\(\\tilde{G}^2 = (\\sqrt{c_2^2 + 4 c_4 b} - c_2) / (2 c_4)\\), where \\(c_2\\) and \\(c_4\\) are the 2nd and 4th order coefficients in Equation 1.\nNow we have coarse approximation to the value for \\(G\\) for which Equation 1 is zero, we can use Newton’s method to approximate it to the required precision.\nFirst we need a function to evaluate a polynomial given an array of coefficients:\n\nimport numpy as np\n\ndef eval_polynomial(c, x):\n    \"\"\"\n    Evaluates the polynomial y = c[0] + c[1] x + c[2] x² + ...\n\n     :param c: List of coefficients or coefficient vectors.\n     :param x: x\n     :return: y\n    \"\"\"\n    y = 0\n    xp = 1\n    \n    for coefficients in c:\n        y += coefficients * xp  # Add the term c[i] * x^i\n        xp *= x  # Calculate x^(i+1)\n\n    return y\n\nThen we can implement the actual root-finding method like this:\n\ndef newtons_method(c, x0, n):\n    \"\"\"\n    Uses Newton's method to find a root of a polynomial with coefficients c, starting at x = x0:\n     0 = c[0] + c[1] x + c[2] x² + ...\n\n     :param c: List of coefficients or coefficient vectors.\n     :param x0: Initial guess.\n     :param n: Number of iterations.\n     :return: Result of Newton's method after n iterations.\n    \"\"\"\n    # Calculate the coefficients for the derivative of the polynomial.\n    d = [i * coef for i, coef in enumerate(c[1:], 1)]\n\n    x = np.array(x0)  # Makes a copy\n    for _ in range(n):  # Perform n iterations.\n        y = eval_polynomial(c, x)  # Evaluate the polynomial for x.\n        dy = eval_polynomial(d, x)  # Evaluate its derivative for x.\n        nonzero = dy != 0  # Prevent division by zero.\n        x[nonzero] -= y[nonzero] / dy[nonzero]\n\n    return x\n\nNow we can calculate the initial estimate \\(\\tilde{G}\\) and a precise value for \\(G\\) as follows:\n\n# Acquisition parameters for which to calculate G.\nb = 750  # s/mm²\nγ = 267598.7  # 1/mT/s\nδ = 0.002  # s\nΔ = 0.02 # s\ns_max = 50  # mT/mm/s\n\n# Calculate the polynomial coefficients.\nc5 = γ ** 2 / (30 * s_max ** 3)\nc4 = -γ ** 2 * δ / (6 * s_max ** 2)\nc2 = (γ * δ) ** 2 * (Δ - δ / 3)\nc0 = -b\nc = [c0, 0, c2, 0, c4, c5]\n\nx0 = np.sqrt((np.sqrt(c2 ** 2 + 4 * c4 * b) - c2) / (2 * c4))  # Initial estimate for G.\ng = newtons_method(c, x0, 5)  # Precise estimate for G, after 5 iterations.\n\ny0 = eval_polynomial(c, x0)\ny = eval_polynomial(c, g)\nprint(f\"Value at initial estimate G={x0:.6f}: {y0:.3f}\")\nprint(f\"Value at precise estimate G={g:.6f}: {y:.3f}\")\n\nValue at initial estimate G=0.464232: 411.732\nValue at precise estimate G=0.379543: 0.000\n\n\nThe plot below shows the estimate for \\(G\\) in each iteration. Note that the estimate for \\(G\\) is at the intersection of the derivative with \\(y=0\\) in the previous iteration.\n\n\nCode\nimport plotly.graph_objects as go\n\n# Calculate the coefficients for the derivative of the polynomial.\nd = [i * coef for i, coef in enumerate(c[1:], 1)]\n\n\nx = np.linspace(0.35, 0.5, 200)\nn = 6  # Number of iterations\nactive = 0  # Initially active slider step\nsteps = []  # Slider steps\n\nfig = go.Figure()\nfig.add_hline(y=0, line={\"color\": \"black\", \"width\": 1})\n\ntrace = go.Scatter(x=x, y=eval_polynomial(c, x), visible=True, name=\"5th order\")\nfig.add_trace(trace)\ntrace = go.Scatter(x=x, y=eval_polynomial([c0, 0, c2, 0, c4, 0], x), visible=True, name=\"approximation\")\nfig.add_trace(trace)\n    \n# Create a figure and a trace for each slider step.\nfor i in range(n):\n    g = newtons_method(c, [x0], i)\n    y = eval_polynomial(c, g)  # Evaluate the polynomial for g.\n    trace = go.Scatter(mode='markers', marker={\"size\": 8, \"symbol\": \"circle\", \"color\": \"black\"},\n                       x=g, y=y, visible=(i == active), name=\"estimated root\")\n    fig.add_trace(trace)\n    \n    dy = eval_polynomial(d, g)  # Evaluate its derivative for g.\n    trace = go.Scatter(mode='lines', line={\"color\": \"black\", \"width\": 1, \"dash\": \"dash\"},\n                       x=[x[0], x[-1]],\n                       y=[dy[0] * (x[0] - g[0]) + y[0], dy[0] * (x[-1] - g[0]) + y[0]],\n                       visible=(i == active), name=\"derivative at estimation\")\n    fig.add_trace(trace)\n    \n    steps.append({\n        \"method\": \"update\",\n        \"label\": str(i),  # This is the label the slider shows.\n        \"args\": [{\"visible\": [True, True] + [i == j//2 for j in range(2*n)]}],  # i-th trace is visible in this step.\n    })\n\nsliders = [{\n    \"active\": active,  # Initially active step.\n    \"currentvalue\": {\"prefix\": \"Iterations: \"},  # Slider info text configuration.\n    \"steps\": steps\n}]\n\nfig.update_layout(\n    sliders=sliders,\n    template=\"seaborn\",\n    xaxis={\"title\": {\"text\": \"G (mT/mm)\"}},\n)\nfig.update_yaxes(range=[-250, 650])  # y-axis are automatically resized otherwise.\n\nfig.show()"
  }
]